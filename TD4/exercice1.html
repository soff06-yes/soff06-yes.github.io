<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8" />
    <title>TP4 IA</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: black;
        }

        #canvas3D {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        #carte2D {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 500px;
            height: 350px;
            border-radius: 10px;
            z-index: 10;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            background: rgba(255, 255, 255, 0.85);
        }

        .point-rouge {
            width: 12px;
            height: 12px;
            background: red;
            border-radius: 50%;
            border: 1px solid #800;
            position: absolute;
            z-index: 20;
        }

        .point-bleu {
            width: 8px;
            height: 8px;
            background: blue;
            border-radius: 50%;
            border: 1px solid #003;
        }

        video#webcam {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 160px;
            border: 2px solid white;
            border-radius: 8px;
            z-index: 20;
        }
    </style>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
</head>
<body>
    <div id="carte2D"></div>
    <canvas id="canvas3D"></canvas>
    <div id="pointMain" class="point-rouge"></div>
    <video id="webcam" autoplay muted></video>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script>
        const DECALAGE_LONGITUDE = -90;
        const carte = L.map("carte2D").setView([0, 0], 2);
        const coucheOSM = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            attribution: "© OpenStreetMap contributors"
        }).addTo(carte);
        const coucheStamen = L.tileLayer("https://stamen-tiles.a.ssl.fastly.net/toner/{z}/{x}/{y}.png", {
            attribution: "© Stamen Design"
        });
        L.control.layers({ "OSM": coucheOSM, "Stamen": coucheStamen }).addTo(carte);

        const pointMain = document.getElementById("pointMain");
        const canvas = document.getElementById("canvas3D");
        const moteur = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(moteur);
        const camera = new BABYLON.ArcRotateCamera("cam", 0, Math.PI / 2, 6, BABYLON.Vector3.Zero(), scene);
        camera.attachControl(canvas, true);
        camera.lowerRadiusLimit = 2.5;
        camera.upperRadiusLimit = 10;
        camera.lowerBetaLimit = null;
        camera.upperBetaLimit = null;

        const lumiere = new BABYLON.HemisphericLight("lumiere", new BABYLON.Vector3(0, 1, 0), scene);
        lumiere.intensity = 1.1;

        const terre = BABYLON.MeshBuilder.CreateSphere("terre", { diameter: 2, segments: 64 }, scene);
        const matTerre = new BABYLON.StandardMaterial("matTerre", scene);
        matTerre.diffuseTexture = new BABYLON.Texture("terre_planete.jpg", scene);
        matTerre.diffuseTexture.uScale = -1;
        matTerre.diffuseTexture.vScale = -1;
        matTerre.specularColor = new BABYLON.Color3(0, 0, 0);
        matTerre.emissiveColor = new BABYLON.Color3(0.2, 0.2, 0.2);
        terre.material = matTerre;

        function latLonEnVecteur(lat, lon, rayon = 1) {
            const phi = (90 - lat) * Math.PI / 180;
            const theta = (lon - 180) * Math.PI / 180;
            return new BABYLON.Vector3(
                rayon * Math.sin(phi) * Math.cos(theta),
                rayon * Math.cos(phi),
                rayon * Math.sin(phi) * Math.sin(theta)
            );
        }

        // --- Drapeaux 3D (avec capitale corrigée) ---
        fetch("https://restcountries.com/v3.1/all?fields=name,latlng,flags,capital")
            .then(res => res.json())
            .then(data => {
                data.forEach(pays => {
                    if (!pays.latlng || !pays.flags?.png) return;
                    const [lat, lon] = pays.latlng;
                    const plan = BABYLON.MeshBuilder.CreatePlane(pays.name.common + "Drapeau", { width: 0.08, height: 0.05 }, scene);
                    plan.position = latLonEnVecteur(lat, lon, 1.05);
                    const matDrapeau = new BABYLON.StandardMaterial(pays.name.common + "Mat", scene);
                    matDrapeau.diffuseTexture = new BABYLON.Texture(pays.flags.png, scene);
                    matDrapeau.specularColor = new BABYLON.Color3(0, 0, 0);
                    plan.material = matDrapeau;
                    plan.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
                    plan.actionManager = new BABYLON.ActionManager(scene);
                    plan.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, () => {
                        carte.setView([lat, lon], 5);
                        camera.alpha = ((lon + 180 + DECALAGE_LONGITUDE) * Math.PI / 180) + Math.PI / 2;
                        camera.beta = (90 - lat) * Math.PI / 180;
                        alert(`Pays : ${pays.name.common}\nCapitale : ${pays.capital?.[0] || 'Inconnue'}`);
                    }));
                });
            });

        // --- Capitales sur carte 2D ---
        fetch("https://restcountries.com/v3.1/all?fields=name,capital,capitalInfo,latlng")
            .then(res => res.json())
            .then(data => {
                window.capitalesData = [];
                data.forEach(pays => {
                    const capitale = pays.capital?.[0];
                    if (!capitale) return;
                    let latlon = pays.capitalInfo?.latlng || pays.latlng;
                    if (!latlon || latlon.length !== 2) return;
                    const [lat, lon] = latlon;
                    window.capitalesData.push({ nom: pays.name.common, lat, lon });
                    const iconeBleue = L.divIcon({ className: "point-bleu", iconSize: [8, 8] });
                    L.marker([lat, lon], { icon: iconeBleue }).addTo(carte)
                        .bindPopup(`<b>${pays.name.common}</b><br>Capitale : ${capitale}`);
                });
            });

        // --- Affichage du pays survolé ---
        let afficherSurSphere = true;
        document.addEventListener("keydown", e => {
            if (e.key === "m") afficherSurSphere = !afficherSurSphere;
        });

        let dernierPays = null;
        let dernierUpdate = 0;
        const TOLERANCE = 0.9935; // ← Ajuste cette valeur : 0.995 = précis, 0.99 = plus tolérant
        const observerPays = () => {
            if (!scene.meshes) return;
            const direction = camera.getDirection(BABYLON.Axis.Z).normalize();
            const positionCam = camera.position;
            let meilleurDrapeau = null;
            let meilleurScore = -Infinity;
            scene.meshes.forEach(mesh => {
                if (!mesh.name.endsWith("Drapeau")) return;
                const dirToFlag = mesh.position.subtract(positionCam);
                const distance = dirToFlag.length();
                const dirNorm = dirToFlag.normalize();
                const cosAngle = BABYLON.Vector3.Dot(direction, dirNorm);
                if (cosAngle <= 0) return; // Drapeau derrière la caméra
                // On combine angle + distance pour un score global
                const score = cosAngle - (distance - 3) * 0.001;
                if (score > meilleurScore) {
                    meilleurScore = score;
                    meilleurDrapeau = mesh;
                }
            });
            const maintenant = performance.now();
            // Si on regarde un drapeau dans la zone de tolérance
            if (meilleurDrapeau && meilleurScore > TOLERANCE) {
                const nomPays = meilleurDrapeau.name.replace("Drapeau", "");
                if (nomPays !== dernierPays || maintenant - dernierUpdate > 1500) {
                    dernierPays = nomPays;
                    dernierUpdate = maintenant;
                    document.getElementById("infoPays")?.remove();
                    const label = document.createElement("div");
                    label.id = "infoPays";
                    label.style.position = "absolute";
                    label.style.top = "10px";
                    label.style.left = "50%";
                    label.style.transform = "translateX(-50%)";
                    label.style.padding = "5px 10px";
                    label.style.color = "white";
                    label.style.background = "rgba(0,0,0,0.5)";
                    label.style.borderRadius = "8px";
                    label.style.transition = "opacity 0.5s ease"; // effet fondu
                    label.style.opacity = "0";
                    label.textContent = `Pays : ${nomPays}`;
                    document.body.appendChild(label);
                    setTimeout(() => (label.style.opacity = "1"), 10);
                }
            } else {
                if (performance.now() - dernierUpdate > 2000) {
                    const label = document.getElementById("infoPays");
                    if (label) {
                        label.style.opacity = "0";
                        setTimeout(() => label.remove(), 500);
                    }
                    dernierPays = null;
                }
            }
        };

        // --- Interaction carte 2D -> sphère 3D ---
        let marqueurClique = L.marker([0, 0], {
            icon: L.divIcon({
                className: '',
                html: '📍',
                iconSize: [22, 22],
                iconAnchor: [10, 20]
            })
        }).addTo(carte);
        marqueurClique.setOpacity(0); // invisible au début
        carte.on('click', function(e) {
            const lat = e.latlng.lat;
            const lon = e.latlng.lng;
            // Affiche le marqueur sur la carte
            marqueurClique.setLatLng([lat, lon]);
            marqueurClique.setOpacity(1);
            // Recentrage de la caméra sur la sphère
            const phi = (90 - lat) * Math.PI / 180;
            const theta = (lon + 180 + DECALAGE_LONGITUDE) * Math.PI / 180;
            camera.alpha = theta + Math.PI / 2;
            camera.beta = phi;
            // Petit zoom automatique pour être plus proche
            camera.radius = 3.5;
        });

        moteur.runRenderLoop(() => {
            scene.render();
            observerPays();
        });

        window.addEventListener("resize", () => moteur.resize());

        // --- Contrôle gestuel fluide ---
        const videoElement = document.getElementById("webcam");
        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        let prevX = 0.5, prevY = 0.5;
        hands.onResults(results => {
            if (!results.multiHandLandmarks) return;
            results.multiHandLandmarks.forEach((landmarks, index) => {
                const handLabel = results.multiHandedness[index].label;
                const wrist = landmarks[0];
                const indexFinger = landmarks[8];
                pointMain.style.left = (window.innerWidth / 2 - 6) + 'px';
                pointMain.style.top = (window.innerHeight / 2 - 6) + 'px';
                const dx = wrist.x - prevX;
                const dy = wrist.y - prevY;
                camera.alpha += dx * 12;
                camera.beta -= dy * 12;
                prevX = wrist.x;
                prevY = wrist.y;
                if (handLabel === "Right") camera.radius -= 0.1;
                if (handLabel === "Left") camera.radius += 0.1;
            });
        });

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { await hands.send({ image: videoElement }) },
            width: 320,
            height: 240
        });
        cameraFeed.start();
    </script>
</body>
</html>
